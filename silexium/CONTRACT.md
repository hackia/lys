# Silexium Contract v1

This document defines the normative, security-critical rules for data formats,
canonicalization, signing, timestamping, and transparency logging.

Terms like MUST, SHOULD, and MAY are to be interpreted as in RFC 2119.

## 1) Canonicalization (JCS)

All JSON objects that are signed MUST be canonicalized using JSON JCS (RFC 8785).
The canonical bytes produced by JCS are the exact bytes that are hashed and signed.

Rules:
- JSON text MUST be UTF-8.
- Object keys MUST be sorted lexicographically per JCS.
- Numbers MUST use the JCS canonical form.
- No insignificant whitespace is permitted in the canonical form.

If any field is computed or hashed, it MUST be based on the JCS bytes.

## 2) Manifest Contract (schema_version = 1)

Each release MUST have a manifest JSON object with this minimal shape:

```
{
  "schema_version": 1,
  "package": "string",
  "version": "string",
  "channel": "string",
  "created_at": "RFC3339",
  "license": "string",
  "hash_algo": "blake3",
  "artifacts": [
    {
      "type": "binary" | "source",
      "os": "string (binary only)",
      "arch": "string (binary only)",
      "size": integer,
      "blake3": "hex",
      "url": "string"
    }
  ],
  "src_index": {
    "path": "SRC",
    "size": integer,
    "blake3": "hex"
  }
}
```

Rules:
- `schema_version` MUST be `1`.
- `hash_algo` MUST be `blake3`.
- `artifacts` MUST include at least one `binary` and exactly one `source`.
- `binary` artifacts MUST include `os` and `arch`.
- `source` artifacts MUST NOT include `os`/`arch`.
- `blake3` fields are 32-byte hashes encoded as lower-case hex.
- Manifest bytes used for hashing MUST be the JCS canonical form.

Manifest hash:
- `manifest_hash = blake3(JCS(manifest))`, encoded as lower-case hex.

Example (non-normative):
- `examples/manifest.json`

## 3) Attestations Contract

Three attestations are REQUIRED for every release:
- `author`
- `tests`
- `server`

Each attestation is represented as:

```
{
  "kind": "author|tests|server",
  "key_id": "hex",
  "payload_hash": "hex",
  "signature": "hex",
  "created_at": "RFC3339",
  "tsa_proof": "bytes",
  "ots_proof": "bytes"
}
```

Key identifiers:
- `key_id` MUST be the lower-case hex encoding of the ed25519 public key bytes.

Signature payload:
- The ed25519 signature MUST be computed over the UTF-8 bytes of `payload_hash`
  exactly as stored (lower-case hex).

Attestation payloads (canonical JSON + JCS):

Author payload MUST include:
```
{
  "schema_version": 1,
  "package": "...",
  "version": "...",
  "channel": "...",
  "manifest_hash": "...",
  "src_index_hash": "...",
  "source_artifact_hash": "...",
  "license": "..."
}
```

Tests payload MUST include:
```
{
  "schema_version": 1,
  "author_attestation_hash": "...",
  "manifest_hash": "...",
  "test_suite_id": "...",
  "test_result": "pass|fail",
  "test_report_hash": "..." (optional)
}
```

Server payload MUST include:
```
{
  "schema_version": 1,
  "author_attestation_hash": "...",
  "tests_attestation_hash": "...",
  "manifest_hash": "...",
  "binary_artifact_hashes": ["..."],
  "source_artifact_hash": "..."
}
```

Payload hashing:
- `payload_hash = blake3(JCS(payload))`, encoded as lower-case hex.

Examples (non-normative):
- `examples/payloads/author.json`
- `examples/payloads/tests.json`
- `examples/payloads/server.json`

## 4) Timestamp Proofs (TSA + OTS)

Each attestation MUST include:
- `tsa_proof` (RFC3161 timestamp response)
- `ots_proof` (OpenTimestamps proof)

Rules:
- Proofs MUST be generated by the Admin tool, not the API server.
- The API server MUST verify proofs before accepting/serving data.

## 5) Key Lifecycle (Mandatory Expiration)

Keys MUST include:
- `role`: author|tests|server
- `created_at` (RFC3339)
- `expires_at` (RFC3339, REQUIRED)
- `revoked_at` (RFC3339, optional)

Validation rules:
- If `now > expires_at`, the key is invalid and MUST be rejected.
- If `revoked_at` is set, the key is invalid and MUST be rejected.
- Role MUST match the attestation kind.

Rotation policy:
- Rotation is REQUIRED before expiration.
- New keys MUST be distributed to all mirrors and clients before use.

## 6) Transparency Log (Merkle + STH + Mirrors)

Entry hash canonicalization:

```
entry_hash = blake3(
  "SILEXIUM-LOG-ENTRY\n" +
  "manifest:" + manifest_hash + "\n" +
  "author:" + author_attestation_hash + "\n" +
  "tests:" + tests_attestation_hash + "\n" +
  "server:" + server_attestation_hash + "\n"
)
```

Merkle hashing (CT-style):
- `leaf_hash = blake3(0x00 || entry_hash_bytes)`
- `node_hash = blake3(0x01 || left || right)`
- MTH uses the largest power-of-two split.

STH payload (signed by server key):
```
"SILEXIUM-STH\n" + tree_size + "\n" + root_hash + "\n" + timestamp + "\n"
```

Mirrors + quorum:
- Clients MUST verify a consistency proof from at least Q distinct mirrors.
- Q is configurable (N/M), default RECOMMENDED: 2-of-M (primary + one mirror).
- At least one mirror MUST be independent from the primary.
- If quorum is not met, the STH MUST be rejected.

## 7) API Contract (Install / Update)

### POST /install
Request:
```
{
  "package": "string",
  "os": "string",
  "arch": "string",
  "version": "string" (optional),
  "channel": "string" (optional),
  "known_sth": { "tree_size": integer, "root_hash": "hex" } (optional)
}
```

Response:
```
{
  "package": "...",
  "version": "...",
  "channel": "...",
  "os": "...",
  "arch": "...",
  "up_to_date": false,
  "manifest": { "format": "json", "bytes_hex": "...", "blake3": "...", "src_index_size": n, "src_index_blake3": "..." },
  "artifacts": [ ... ],
  "attestations": [ ... ],
  "log": { "tree_size": n, "leaf_index": n, "entry_hash": "...", "leaf_hash": "...", "inclusion": ["..."], "consistency": ["..."] | null, "sth": { ... } }
}
```

### POST /update
Request:
```
{
  "package": "string",
  "os": "string",
  "arch": "string",
  "current_version": "string",
  "channel": "string" (optional),
  "known_sth": { "tree_size": integer, "root_hash": "hex" } (optional)
}
```

Response is identical to /install, with `up_to_date` true/false.
